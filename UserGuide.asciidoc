= Lightsleep 3.1.0 User's Guide

link:UserGuide_ja.asciidoc[Japanese]

[[TOC_]]
=== Table of Contents

1. <<Package,Package>> +
2. <<EntityClass,Create entity classes>> +
2-1. <<Entity-Annotation,Annotations to be used in entity classes>> +
2-1-1. <<Entity-Table,@Table>> +
2-1-2. <<Entity-Key,@Key>> +
2-1-3. <<Entity-Column,@Column>> +
2-1-4. <<Entity-ColumnType,@ColumnType>> +
2-1-5. <<Entity-NonColumn,@NonColumn>> +
2-1-6. <<Entity-NonSelect,@NonSelect>> +
2-1-7. <<Entity-NonInsert,@NonInsert>> +
2-1-8. <<Entity-NonUpdate,@NonUpdate>> +
2-1-9. <<Entity-Select,@Select>> +
2-1-10. <<Entity-Insert,@Insert>> +
2-1-11. <<Entity-Update,@Update>> +
2-1-12. <<Entity-XxxxxProperty,@KeyProperty, @ColumnProperty, ... and @UpdateProperty>> +
2-2. <<Entity-Interface,Interfaces implemented by entity classes>> +
2-2-1. <<Entity-PreInsert,PreInsert Interface>> +
2-2-2. <<Entity-Composite,Composite Interface>> +
2-2-3. <<Entity-PreStore,PreStore Interface>> +
2-2-4. <<Entity-PostLoad,PostLoad Interface>> +
3. <<lightsleep-properties,Definition of lightsleep.properties file>> +
3-1. <<Logger,Logging library class>> +
3-2. <<Database,Database handler class>> +
3-3. <<ConnectionSupplier,Connection supplier class>> +
4. <<Transaction,Transaction>> +
5. <<ExecuteSQL,Execution of SQL>> +
5-1. <<ExecuteSQL-select,SELECT>> +
5-1-1. <<ExecuteSQL-select-1-Expression,SELECT 1 row with an Expression condition>> +
5-1-2. <<ExecuteSQL-select-Entity,SELECT 1 row with an Entity condition>> +
5-1-3. <<ExecuteSQL-select-N-Expression,SELECT multiple rows with an Expression condition>> +
5-1-4. <<ExecuteSQL-select-Subquery,SELECT with a Subquery condition>> +
5-1-5. <<ExecuteSQL-select-Expression-and,SELECT with Expression conditions AND>> +
5-1-6. <<ExecuteSQL-select-Expression-or,SELECT with Expression conditions OR>> +
5-1-7. <<ExecuteSQL-select-Expression-andor,SELECT with Expression conditions (A AND B) OR (C AND D)>> +
5-1-8. <<ExecuteSQL-select-columns,SELECT with selection of columns>> +
5-1-9. <<ExecuteSQL-select-groupBy-having,SELECT with GROUP BY and HAVING>> +
5-1-10. <<ExecuteSQL-select-orderBy-offset-limit,SELECT with ORDER BY, OFFSET and LIMIT>> +
5-1-11. <<ExecuteSQL-select-forUpdate,SELECT with FOR UPDATE>> +
5-1-12. <<ExecuteSQL-select-innerJoin,SELECT with INNER JOIN>> +
5-1-13. <<ExecuteSQL-select-leftJoin,SELECT with LEFT OUTER JOIN>> +
5-1-14. <<ExecuteSQL-select-rightJoin,SELECT with RIGHT OUTER JOIN>> +
5-1-15. <<ExecuteSQL-select-count,SELECT COUNT(*)>> +
5-1-16. <<ExecuteSQL-select-fromSubquery,SELECT FROM Clause Subquery [small fuchsia]#_(v3.1.0~)_#>> +
5-1-17. <<ExecuteSQL-select-union,SELECT UNION, UNION ALL [small fuchsia]#_(v3.1.0~)_#>> +
5-2. <<ExecuteSQL-insert,INSERT>> +
5-2-1. <<ExecuteSQL-insert-1,INSERT 1 row>> +
5-2-2. <<ExecuteSQL-insert-N,INSERT multiple rows>> +
5-3. <<ExecuteSQL-update,UPDATE>> +
5-3-1. <<ExecuteSQL-update-1,UPDATE 1 row>> +
5-3-2. <<ExecuteSQL-update-N,UPDATE multiple rows>> +
5-3-3. <<ExecuteSQL-update-Condition,UPDATE with a Condition and selection of columns>> +
5-3-4. <<ExecuteSQL-update-all,UPDATE all rows>> +
5-4. <<ExecuteSQL-delete,DELETE>> +
5-4-1. <<ExecuteSQL-delete-1,DELETE 1 row>> +
5-4-2. <<ExecuteSQL-delete-N,DELETE multiple rows>> +
5-4-3. <<ExecuteSQL-delete-Condition,DELETE with a Condition>> +
5-4-4. <<ExecuteSQL-delete-all,DELETE all rows>> +
6. <<Expression,Expression Conversion>> +
7. <<DateTime,Mappings of Java types and column types in datetime types>> +
7-1. <<DateTime-DB2,DB2>> +
7-2. <<DateTime-MySQL,MySQL>> +
7-3. <<DateTime-Oracle,Oracle>> +
7-4. <<DateTime-PostgreSQL,PostgreSQL>> +
7-5. <<DateTime-SQLite,SQLite>> +
7-6. <<DateTime-SQLServer,SQL Server>> +

[[Package]]

<<TOC_,To TOC>>

=== 1. Packages

Has the following packages.

.Packages
[options="header", width="80%"]
|===
|Package|Contained classes and interfaces
|org.lightsleep                |Classes you use primarily
|org.lightsleep.component      |Classes you use to create SQL components such as conditions and expressions
|org.lightsleep.connection     |Classes that supply connection wrapper classes to this library using various connection pool libraries
|org.lightsleep.database       |Classes for generating SQL for various DBMSs
|org.lightsleep.database.anchor|Classes used in mapping words contained in JDBC URLs to classes in the *org.lightsleep.database* package
|org.lightsleep.entity         |Annotation classes and interfaces you use when creating entity classes
|org.lightsleep.helper         |Helper classes used inside this library
|org.lightsleep.logger         |Classes that output logs inside this library using various logging libraries
|===

[[EntityClass]]

<<TOC_,To TOC>>

=== 2. Create entity classes
Create corresponding entity classes for each table in the database.

[[Entity-Annotation]]

==== 2-1. Annotations to be used in entity classes
Lihgtsleep automatically associates with tables in methods with an entity class or object as an argument, but you may also need to use annotations for entity classes.

Lightsleep has the following annotations.

.Annotations
[options="header", width="100%"]
|===
|Annotation Type|Element(s)|Content of Indication|Target
|<<Entity-Table,`@Table`>>
|`String value`
|Related table name
|Class

|<<Entity-Key,`@Key`>>
|`boolean value` (default: `true`)
|Related to the primary key
|Field

|<<Entity-Column,`@Column`>>
|`String value`
|Related column name
|Field

|<<Entity-ColumnType,`@ColumnType`>>
|`Class<?> value`
|Related column type
|Field

|<<Entity-NonColumn,`@NonColumn`>>
|`boolean value` (default: `true`)
|Not related to any column
|Field

|<<Entity-NonSelect,`@NonSelect`>>
|`boolean value` (default: `true`)
|Not used in SELECT SQL
|Field

|<<Entity-NonInsert,`@NonInsert`>>
|`boolean value` (default: `true`)
|Not used in INSERT SQL
|Field

|<<Entity-NonUpdate,`@NonUpdate`>>
|`boolean value` (default: `true`)
|Not used in UPDATE SQL
|Field

|<<Entity-Select,`@Select`>>
|String value
|Expression used in SELECT SQL
|Field

|<<Entity-Insert,`@Insert`>>
|String value
|Expression used in INSERT SQL
|Field

|<<Entity-Update,`@Update`>>
|String value
|Expression used in UPDATE SQL
|Field

|<<Entity-XxxxxProperty,`@KeyProperty`>>
|`String property`, +
`boolean value` (default: `true`)
|Related to the primary key
|Class

|<<Entity-XxxxxProperty,`@ColumnProperty`>>
|`String property`, +
String column
|Related column name
|Class

|<<Entity-XxxxxProperty,`@ColumnTypeProperty`>>
|`String property`, +
`Class<?> type`
|Related column type
|Class

|<<Entity-XxxxxProperty,`@NonColumnProperty`>>
|`String property`, +
`boolean value` (default: `true`)
|Not related to any columns
|Class

|<<Entity-XxxxxProperty,`@NonSelectProperty`>>
|`String property`, +
`boolean value` (default: `true`)
|Not used in SELECT SQL
|Class

|<<Entity-XxxxxProperty,`@NonInsertProperty`>>
|`String property`, +
`boolean value` (default: `true`)
|Not used in INSERT SQL
|Class

|<<Entity-XxxxxProperty,`@NonUpdateProperty`>>
|`String property`, +
`boolean value` (default: `true`)
|Not used in UPDATE SQL
|Class

|<<Entity-XxxxxProperty,`@SelectProperty`>>
|`String property`, +
`String expression`
|Expression used in SELECT SQL
|Class

|<<Entity-XxxxxProperty,`@InsertProperty`>>
|`String property`, +
`String expression`
|Expression used in INSERT SQL
|Class

|<<Entity-XxxxxProperty,`@UpdateProperty`>>
|`String property`, +
`String expression`
|Expression used in UPDATE SQL
|Class
|===

[[Entity-Table]]

<<TOC_,To TOC>> +
<<Entity-Annotation,To Annotation List>>

===== 2-1-1. @Table
Specifies the table name related to the class.
If the table name is the same as the class name, you do not need to specify this annotation.

[source,java]
.Java
----
@Table("Contact")
public class Person extends PersonBase {

    @Table("super")
     public static class Ex extends Person {
----

[source,groovy]
.Groovy
----
@Table('Contact')
class Person extends PersonBase {

    @Table('super')
     static class Ex extends Person {
----

If you specify `@Table("super")`, the class name of the superclass is the table name.

[[Entity-Key]]

===== 2-1-2. @Key
Indicates that the column related to the field is part of the primary key.

[source,java]
.Java
----
@Key
public int contactId;
@Key
public short featureIndex;
----

[source,groovy]
.Groovy
----
@Key
int contactId
@Key
short featureIndex
----

[[Entity-Column]]

===== 2-1-3. @Column
Indicates the name of column related to the field.
If the column name is the same as the field name, you do not need to specify it.

[source,java]
.Java
----
@Column("firstName")
public String first;
@Column("lastName")
public String last;
----

[source,groovy]
.Groovy
----
@Column('firstName')
String first
@Column('lastName')
String last
----

[[Entity-ColumnType]]

===== 2-1-4. @ColumnType
Indicates the type of column related to the field.
If the field type and column type are the same type, you do not need to specify it.
Specify if field type (e.g. date type) and column type (e.g. numerical type) are different.

[source,java]
.Java
----
@ColumnType(Long.class)
public LocalDate birthday;
----

[source,groovy]
.Groovy
----
@ColumnType(Long)
LocalDate birthday
----

[[Entity-NonColumn]]

<<TOC_,To TOC>> +
<<Entity-Annotation,To Annotation List>>

===== 2-1-5. @NonColumn
Indicates that the field not related to any column.

[source,java]
.Java
----
@NonColumn
public List<Phone> phones;
@NonColumn
public List<Address> addresses;
----

[source,groovy]
.Groovy
----
@NonColumn
List<Phone> phones
@NonColumn
List<Address> addresses
----

[[Entity-NonSelect]]

===== 2-1-6. @NonSelect
Indicates that the column related the field is not used in SELECT SQL.

[source,java]
.Java
----
@NonSelect
public LocalDateTime createdTime;
@NonSelect
public LocalDateTime updatedTime;
----

[source,groovy]
.Groovy
----
@NonSelect
LocalDateTime createdTime
@NonSelect
LocalDateTime updatedTime
----

[[Entity-NonInsert]]

===== 2-1-7. @NonInsert
Indicates that the column related the field is not used in INSERT SQL.

[source,java]
.Java
----
@NonInsert
public LocalDateTime createdTime;
@NonInsert
public LocalDateTime updatedTime;
----

[source,groovy]
.Groovy
----
@NonInsert
LocalDateTime createdTime
@NonInsert
LocalDateTime updatedTime
----

[[Entity-NonUpdate]]

===== 2-1-8. @NonUpdate
Indicates that the column related the field is not used in UPDATE SQL.

[source,java]
.Java
----
@NonUpdate
public LocalDateTime createdTime;
----

[source,groovy]
.Groovy
----
@NonUpdate
LocalDateTime createdTime
----

[[Entity-Select]]

<<TOC_,To TOC>> +
<<Entity-Annotation,To Annotation List>>

===== 2-1-9. @Select
Indicates a column expression instead of the column name in SELECT SQL.

[source,java]
.Java
----
@Select("{firstName}||' '||{lastName}")
@NonInsert@NonUpdate
public String fullName;
----

[source,groovy]
.Groovy
----
@Select("{firstName}||' '||{lastName}")
@NonInsert@NonUpdate
String fullName
----

[[Entity-Insert]]

===== 2-1-10. @Insert
Indicates an expression instead of the field value in INSERT SQL.
If this annotation is specified, the value of the field is not used.

[source,java]
.Java
----
@Insert("CURRENT_TIMESTAMP")
public LocalDateTime createdTime;
@Insert("CURRENT_TIMESTAMP")
public LocalDateTime updatedTime;
----

[source,groovy]
.Groovy
----
@Insert('CURRENT_TIMESTAMP')
LocalDateTime createdTime
@Insert('CURRENT_TIMESTAMP')
LocalDateTime updatedTime
----

[[Entity-Update]]

===== 2-1-11. @Update
Indicates an expression instead of the field value in UPDATE SQL.
If this annotation is specified, the value of the field is not used.

[source,java]
.Java
----
@Update("{updateCount}+1")
public int updateCount;
@Update("CURRENT_TIMESTAMP")
public LocalDateTime updatedTime;
----

[source,groovy]
.Groovy
----
@Update('{updateCount}+1')
int updateCount
@Update('CURRENT_TIMESTAMP')
LocalDateTime updatedTime
----

[[Entity-XxxxxProperty]]

<<TOC_,To TOC>> +
<<Entity-Annotation,To Annotation List>>

===== 2-1-12. @KeyProperty, @ColumnProperty, ... and @UpdateProperty
These annotations are used to specify for fields defined in superclass.
The specified contents also affects subclasses, but specifications in the subclass takes precedence.
If you specify `value=false`, `column=""`, `type=Void.class` or `expression=""`, specifications in the superclass are canceled.

[source,java]
.Java
----
@KeyProperty(property="contactId")
@KeyProperty(property="featureIndex")
public class ContactFeature extends ContactFeatureKey {
----

[source,groovy]
.Groovy
----
@KeyProperties([
    @KeyProperty(property='contactId'),
    @KeyProperty(property='featureIndex')
])
class ContactFeature extends ContactFeatureKey {
----

=== 2-2. Interfaces implemented by entity classes

[[Entity-PreInsert]]

<<TOC_,To TOC>>

==== 2-2-1. PreInsert Interface
If an entity class implements this interface, `insert` method of Sql class calls `preInsert` method of the entity before INSERT SQL execution.
In `preInsert` method, do the implementation of the numbering of the primary key or etc.

[source,java]
.Java
----
public abstract class Common implements PreInsert {
    @Key
    public int id;
        ...

    @Override
    public int preInsert(ConnectionWrapper conn) {
        id = Numbering.getNewId(conn, getClass());
        return 0;
    }
}
----

[[Entity-Composite]]

<<TOC_,To TOC>>

==== 2-2-2. Composite Interface
If an entity class implements this interface, `select`, `insert`, `update` or `delete` method of `Sql` class calls `postSelect`, `postInsert`, `postUpdate` or `postDelete` method of the entity class after the execution of each execute SQL.
However if `update` or `delete` method dose not have entity parameter, dose not call.
If an entity is enclose another entity, by implementing this interface, You can perform SQL processing to the enclosed entity in conjunction the entity which encloses.

[source,java]
.Java
----
@Table("super")
public class ContactComposite extends Contact implements Composite {
    @NonColumn
    public final List<Phone> phones = new ArrayList<>();

    @Override
    public void postSelect(ConnectionWrapper conn) {
        if (id != 0) {
            new Sql<>(Phone.class)
                .where("{contactId}={}", id)
                .orderBy("{phoneNumber}")
                .connection(conn)
                .select(phones::add);
        }
    }

    @Override
    public int postInsert(ConnectionWrapper conn) {
        phones.forEach(phone -> phone.contactId = id);
        int count = new Sql<>(Phone.class)
            .connection(conn)
            .insert(phones);
        return count;
    }

    @Override
    public int postUpdate(ConnectionWrapper conn) {
        List<Integer> phoneIds = phones.stream()
            .map(phone -> phone.id)
            .filter(id -> id != 0)
            .collect(Collectors.toList());

        // Delete phones
        int count += new Sql<>(Phone.class)
            .where("{contactId}={}", id)
            .doIf(phoneIds.size() > 0,
                sql -> sql.and("{id} NOT IN {}", phoneIds)
            )
            .connection(conn)
            .delete();

        // Uptete phones
        count += new Sql<>(Phone.class)
            .connection(conn)
            .update(phones.stream()
                .filter(phone -> phone.id != 0)
                .collect(Collectors.toList()));

        // Insert phones
        count += new Sql<>(Phone.class)
            .connection(conn)
            .insert(phones.stream()
                .filter(phone -> phone.id == 0)
                .collect(Collectors.toList()));

        return count;
    }

    @Override
    public int postDelete(ConnectionWrapper conn) {
        int count = new Sql<>(Phone.class)
            .where("{contactId}={}", id)
            .connection(conn)
            .delete();
        return count;
    }
----

[[Entity-PreStore]]

<<TOC_,To TOC>>

==== 2-2-3. PreStore Interface
If the entity class implements this interface, the `preStore` method of the entity class is called in the `insert` and `update` methods of the `Sql` class before each SQL is executed.

[[Entity-PostLoad]]

==== 2-2-4. PostLoad Interface
If the entity class implements this interface, `postLoad` method of the entity class is called in the `select` methods of the `Sql` class after the SELECT SQL is executed and the entity's value obtained from the database is set.

[source,java]
.Java
----
import org.lightsleep.entity.*;

public class Contact implements PreStore, PostLoad {

    @Column("phone")
    public String[] phones_

    @NonColumn
    public final List<String> phones = new ArrayList<>();

    public void preStore() {
        phones_ = phones.toArray(new String[phones.size()]);
    }

    public void postLoad() {
        phones.clear();
        Arrays.stream(phones_).forEach(phones::add);
    }
----
[[lightsleep-properties]]

<<TOC_,To TOC>>

=== 3. Definition of lightsleep.properties

Lightsleep.properties is a properties file referenced by Lightsleep and you can specify the following contents. +
*(The `Database` property up to version 2.0.0 has been removed in version 2.1.0, the database handler is automatically determined from the corresponding JDBC URL.)*

[options="header", width="80%"]
|===
|Property Name|Content|Default Value
|`<<Logger,Logger>>`
|Logging class
|`Std$Out$Info`

|`<<ConnectionSupplier,ConnectionSupplier>>`
|Connection Supplier class
|`Jdbc`

|`url`                   |JDBC URL|None
|`urls`                  |JDBC URLs|None
|`dataSource`            |Data source name when using `Jndi`|None
|`dataSources`           |Data source names when using `Jndi`|None
|`maxStringLiteralLength`|Maximum length of string literals when generates SQL|128
|`maxBinaryLiteralLength`|Maximum length of binary literals when generates SQL|128
|`maxLogStringLength`    |Maximum length of string values output to log|200
|`maxLogByteArrayLength` |Maximum number of elements of byte arrays output to log|200
|`maxLogArrayLength`     |Maximum number of elements of arrays output to log|100
|`maxLogMapSize`         |Maximum number of elements of maps output to log|100

|`connectionLogFormat` +
[small fuchsia]#_(since 2.2.0)_#
|The log output format of `ConnectionSupplier` +
*String replacements:* +
*{0}*: To the simple class name of the database handler +
*{1}*: To the simple class name of the connection supplier +
*{2}*: To the JDBC URL of the connection
|`[{0}/{1}]`
|===

Place the `lightsleep.properties` file in one of the class paths. Or you can specify the file path with the system property `lightsleep.resource`. *(java -Dlightsleep.resource=...)*  +
In addition to the above define the properties used by the connection pool library.

Example of lightsleep.properties:

[source,properties]
.lightsleep.properties
----
Logger      = Log4j2
ConnectionSupplier = Dbcp
url         = jdbc:postgresql://postgresqlserver/example
username    = example
password    = _example_
initialSize = 10
maxTotal    = 100
----

You can specify multiple JDBC URLs in the `urls` property separated by commas. [small fuchsia]#_(since 2.1.0)_#  +
If you define a property with more than one line, append a backslash (`\`) to the end of the line other than the last line.  +
If you specify `urls`, the specification of `url` will be invalid.

[source,properties]
.lightsleep.properties - Case of specifying multiple JDBC URLs
----
Logger      = Log4j2
ConnectionSupplier = Dbcp
urls        = jdbc:postgresql://postgresqlserver/example1,\
              jdbc:postgresql://postgresqlserver/example2
user        = example
password    = _example_
initialSize = 10
maxTotal    = 100
----

You can specify a different DBMS URL for each JDBC URL. If the user and password are different for each JDBC URL, specify them in the URL.

[source,properties]
.lightsleep.properties - Case of using multiple DBMS (specifying user and password in URL)
----
Logger = Log4j2
ConnectionSupplier = Dbcp
urls = \
    jdbc:db2://db2-11:50000/example:user=example;password=_example_;,\
    jdbc:mysql://mysql57/example?user=example&password=_example_,\
    jdbc:oracle:thin:example/_example_@oracle121:1521:example,\
    jdbc:postgresql://postgresql101/example?user=example&password=_example_,\
    jdbc:sqlite:C:/sqlite/example,\
    jdbc:sqlserver://sqlserver13;database=example;user=example;password=_example_,\

initialSize = 10
maxTotal    = 100
----

To specify a connection supplier for each URL, write it within `[]` at the head of the URL. [small fuchsia]#_(since 2.1.0)_#  +
The specification of this form takes precedence over the specification of `ConnectionSupplier` property.  +
You can specify the `username` and `jdbcUrl` property with the `user` and `url` property, but specify properties other than those with the property name specific to the connection pool library.

[source,properties]
.lightsleep.properties - Case of specifying a connection supplier for each URL
----
Logger = Log4j2
urls = \
    [  Jdbc  ]jdbc:db2://db2-11:50000/example:user=example;password=_example_;,\
    [  C3p0  ]jdbc:mysql://mysql57/example?user=example&password=_example_,\
    [  Dbcp  ]jdbc:oracle:thin:example/_example_@oracle121:1521:example,\
    [HikariCP]jdbc:postgresql://postgresql101/example?user=example&password=_example_,\
    [TomcatCP]jdbc:sqlite:C:/sqlite/example,\
    [  Jdbc  ]jdbc:sqlserver://sqlserver13;database=example;user=example;password=_example_,\

# Dbcp, HikariCP, TomcatCP
initialSize = 10

# Dbcp
maxTotal    = 10

# TomcatCP
maxActive   = 10

# HikariCP
minimumIdle     = 10
maximumPoolSize = 10
----

[[Logger]]

<<TOC_,To TOC>> <<lightsleep-properties,[To Properties List]>>

==== 3-1. Logging library class

Select the value of the `Logger` property from the following.

[options="header", width="80%"]
|===
|Value|Logging library etc.|Log level|Definition file used by the logging library
|`Jdk`          |Java Runtime        |-    |logging.properties
|`Log4j`        |Log4j               |-    |log4j.properties or log4j.xml
|`Log4j2`       |Log4j 2             |-    |log4j2.xml
|`SLF4J`        |SLF4J               |-    |Depends on target logging library implementation
|`Std$Out$Trace`|Output to System.out|trace|_(nothing)_
|`Std$Out$Debug`|_(same as above)_   |debug|_(nothing)_
|`Std$Out$Info` |_(same as above)_   |info |_(nothing)_
|`Std$Out$Warn` |_(same as above)_   |warn |_(nothing)_
|`Std$Out$Error`|_(same as above)_   |error|_(nothing)_
|`Std$Out$Fatal`|_(same as above)_   |fatal|_(nothing)_
|`Std$Err$Trace`|Output to System.err|trace|_(nothing)_
|`Std$Err$Debug`|_(same as above)_   |debug|_(nothing)_
|`Std$Err$Info` |_(same as above)_   |info |_(nothing)_
|`Std$Err$Warn` |_(same as above)_   |warn |_(nothing)_
|`Std$Err$Error`|_(same as above)_   |error|_(nothing)_
|`Std$Err$Fatal`|_(same as above)_   |fatal|_(nothing)_
|===

If you do not specify it, `Std$Out$Info` is selected.

[[Database]]

<<TOC_,To TOC>> <<lightsleep-properties,[To Properties List]>>

==== 3-2. Database handler class

The database handler class is automatically selected from the contents of the JDBC URL specified in the `url` or `urls` property. [small fuchsia]#_(since 2.1.0)_#

[options="header", width="60%"]
|===
|Word included in JDBC URL|Selected class|Corresponding DBMS
|`db2`       |`DB2`       |link:https://www.ibm.com/us-en/marketplace/db2-express-c[DB2]
|`mysql`     |`MySQL`     |link:https://www.mysql.com/[MySQL]
|`oracle`    |`Oracle`    |link:https://www.oracle.com/database/index.html[Oracle Database]
|`postgresql`|`PostgreSQL`|link:https://www.postgresql.org/[PostgreSQL]
|`sqlite`    |`SQLite`    |link:https://sqlite.org/index.html[SQLite]
|`sqlserver` |`SQLServer` |link:https://www.microsoft.com/ja-jp/sql-server/sql-server-2016[Microsoft SQL Server]
|===

If the JDBC URL does not contain any of the words above, `Standard` class is selected.

[[ConnectionSupplier]]

<<TOC_,To TOC>> <<lightsleep-properties,[To Properties List]>>

==== 3-3. Connection supplier class

Select the value of the `ConnectionSupplier` property from the following.

[options="header", width="80%"]
|===
|Value|Corresponding connection pool libraries
|`C3p0`    |link:http://www.mchange.com/projects/c3p0/[c3p0]
|`Dbcp`    |link:https://commons.apache.org/proper/commons-dbcp/[Apache Commons DBCP]
|`HikariCP`|link:http://brettwooldridge.github.io/HikariCP/[HikariCP]
|`TomcatCP`|link:http://tomcat.apache.org/tomcat-8.5-doc/jdbc-pool.html[Tomcat JDBC Connection Pool]
|`Jndi`    |Java Naming and Directory Interface (JNDI) (link:http://tomcat.apache.org/tomcat-8.5-doc/jndi-datasource-examples-howto.html[In the case of Tomcat])
|`Jdbc`    |`DriverManager#getConnection(String url, Properties info)` Method
|===

Also define the information required by the connection pool library in the lightsleep.properties file.
Below the ConnectionSupplier (from `url`) in definition examples of lightsleep.properties are the definition contents to be passed to the connection supplier.

[source,properties]
.lightsleep.properties - Jdbc
----
ConnectionSupplier = Jdbc
url      = jdbc:db2://db2-11:50000/example
user     = example
password = _example_
----

[source,properties]
.lightsleep.properties - C3p0
----
ConnectionSupplier = C3p0
url      = jdbc:mysql://mysql57/example
user     = example
password = _example_
----

[source,properties]
.c3p0.properties
----
c3p0.initialPoolSize = 20
c3p0.minPoolSize     = 10
c3p0.maxPoolSize     = 30
----

[source,properties]
.lightsleep.properties - Dbcp
----
ConnectionSupplier = Dbcp
url         = jdbc:oracle:thin:@oracle121:1521:example
user        = example
  or
username    = example
password    = _example_
initialSize = 20
maxTotal    = 30
----

[source,properties]
.lightsleep.properties - HikariCP
----
ConnectionSupplier = HikariCP
url             = jdbc:postgresql://postgres96/example
  or
jdbcUrl         = jdbc:postgresql://postgres96/example
user            = example
  or
username        = example
password        = _example_
minimumIdle     = 10
maximumPoolSize = 30
----

[source,properties]
.lightsleep.properties - TomcatCP
----
ConnectionSupplier = TomcatCP
url         = jdbc:sqlserver://sqlserver13;database=example
user        = example
  or
username    = example
password    = _example_
initialSize = 20
maxActive   = 30
----

[source,properties]
.lightsleep.properties - Jndi
----
ConnectionSupplier = Jndi
dataSource         = jdbc/example
  or
dataSource         = example
----

[[Transaction]]

<<TOC_,To TOC>>

=== 4. Transaction
Execution of `Transaction.execute` method is equivalent to the execution of a transaction.
Define contents of the transaction by the argument `transaction` as a lambda expression.
The lambda expression is equivalent to the contents of `Transaction.executeBody` method and the argument of this method is a `ConnectionWrapper`.

[source,java]
.Java
----
Contact contact = new Contact(1, "Akane", "Apple");

Transaction.execute(conn -> {
    // Start of transaction
    new Sql<>(Contact.class)
        .connection(conn)
        .insert(contact);
    ...
    // End of transaction
});
----

[source,groovy]
.Groovy
----
def contact = new Contact(1, 'Akane', 'Apple')

Transaction.execute {
    // Start of transaction
    new Sql<>(Contact)
        .connection(it)
        .insert(contact)
    ...
    // End of transaction
}
----

If you define multiple JDBC URLs in `lightsleep.properties`, you need to specify which URL to execute the transaction.
The `ConnectionSupplier.find` method searches for a JDBC URL that contains all of the string array of arguments.
An exception will be thrown if more than one is found or if it can not be found.

[source,java]
.Java
----
public static final ConnectionSupplier supplier1 = ConnectionSupplier.find("example1");
    ...

Contact contact = new Contact(1, "Akane", "Apple");

Transaction.execute(supplier1, conn -> {
    // Start of transaction
    new Sql<>(Contact.class)
        .connection(conn)
        .insert(contact);
   ...
    // End of transaction
});
----

[source,groovy]
.Groovy
----
static final supplier1 = ConnectionSupplier.find('example1')
    ...

def contact = new Contact(1, 'Akane', 'Apple')

Transaction.execute(supplier1) {
    // Start of transaction
    new Sql<>(Contact)
        .connection(it)
        .insert(contact)
    ...
    // End of transaction
}
----

If an exception is thrown during the transaction, `Transaction.rollback` method is called.
Otherwise, `Transaction.commit` method is called.

[[ExecuteSQL]]

<<TOC_,To TOC>>

=== 5. Execution of SQL
Use the various methods of `Sql` class to execute SQLs and define it in the lambda expression argument of `Transaction.execute` method.

[[ExecuteSQL-select]]

==== 5-1. SELECT

[[ExecuteSQL-select-1-Expression]]

==== 5-1-1. SELECT 1 row with an Expression condition

[source,java]
.Java
----
Transaction.execute(conn -> {
    Optional<Contact> contactOpt = new Sql<>(Contact.class)
        .where("{id}={}", 1)
        .connection(conn)
        .select();
});
----

[source,groovy]
.Groovy
----
Transaction.execute {
    def contactOpt = new Sql<>(Contact)
        .where('{id}={}', 1)
        .connection(it)
        .select()
}
----

[source,sql]
.Generated SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE id=1
----

[[ExecuteSQL-select-Entity]]

<<TOC_,To TOC>>

==== 5-1-2. SELECT 1 row with an Entity condition

[source,java]
.Java
----
Contact contact = new Contact();
contact.id = 1;
Transaction.execute(conn -> {
    Optional<Contact> contactOpt = new Sql<>(Contact.class)
        .where(contact)
        .connection(conn)
        .select();
});
----

[source,groovy]
.Groovy
----
def contact = new Contact()
contact.id = 1
Transaction.execute {
    def contactOpt = new Sql<>(Contact)
        .where(contact)
        .connection(it)
        .select()
}
----

[source,sql]
.Generated SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE id=1
----

[[ExecuteSQL-select-N-Expression]]

<<TOC_,To TOC>>

==== 5-1-3. SELECT multiple rows with an Expression condition

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apple")
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apple')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.Generated SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE lastName='Apple'
----

[[ExecuteSQL-select-Subquery]]

<<TOC_,To TOC>>

==== 5-1-4. SELECT with a Subquery condition

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class, "C")
        .where("EXISTS",
            new Sql<>(Phone.class, "P")
                .where("{P.contactId}={C.id}")
        )
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact, 'C')
        .where('EXISTS',
            new Sql<>(Phone, 'P')
                .where('{P.contactId}={C.id}')
        )
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.Generated SQL
----
SELECT C.id C_id, C.firstName C_firstName, C.lastName C_lastName, C.birthday C_birthday, C.updateCount C_updateCount, C.createdTime C_createdTime, C.updatedTime C_updatedTime
  FROM Contact C
  WHERE EXISTS (SELECT * FROM Phone P WHERE P.contactId=C.id)
----

[[ExecuteSQL-select-Expression-and]]

<<TOC_,To TOC>>

==== 5-1-5. SELECT with Expression conditions (AND)

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apple")
        .and  ("{firstName}={}", "Akane")
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apple')
        .and  ('{firstName}={}', 'Akane')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.Generated SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE lastName='Apple' AND firstName='Akane'
----

[[ExecuteSQL-select-Expression-or]]

<<TOC_,To TOC>>

==== 5-1-6. SELECT with Expression Condition (OR)

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apple")
        .or   ("{lastName}={}", "Orange")
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apple')
        .or   ('{lastName}={}', 'Orange')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.Generated SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE lastName='Apple' OR lastName='Orange'
----

[[ExecuteSQL-select-Expression-andor]]

<<TOC_,To TOC>>

==== 5-1-7. SELECT with Expression conditions A AND B OR C AND D

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where(Condition
            .of ("{lastName}={}", "Apple")
            .and("{firstName}={}", "Akane")
        )
        .or(Condition
            .of ("{lastName}={}", "Orange")
            .and("{firstName}={}", "Setoka")
        )
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .where(Condition
            .of ('{lastName}={}', 'Apple')
            .and('{firstName}={}', 'Akane')
        )
        .or(Condition
            .of ('{lastName}={}', 'Orange')
            .and('{firstName}={}', 'Setoka')
        )
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.Generated SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  WHERE lastName='Apple' AND firstName='Akane' OR lastName='Orange' AND firstName='Setoka'
----

[[ExecuteSQL-select-columns]]

<<TOC_,To TOC>>

==== 5-1-8. SELECT with selection of columns

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apple")
        .columns("lastName", "firstName")
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apple')
        .columns('lastName', 'firstName')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.Generated SQL
----
SELECT firstName, lastName FROM Contact WHERE lastName='Apple'
----

[[ExecuteSQL-select-groupBy-having]]

<<TOC_,To TOC>>

==== 5-1-9. SELECT with GROUP BY and HAVING

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class, "C")
        .columns("lastName")
        .groupBy("{lastName}")
        .having("COUNT({lastName})>=2")
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact, 'C')
        .columns('lastName')
        .groupBy('{lastName}')
        .having('COUNT({lastName})>=2')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.Generated SQL
----
SELECT MIN(C.lastName) C_lastName
  FROM Contact C
  GROUP BY C.lastName
  HAVING COUNT(C.lastName)>=2
----

[[ExecuteSQL-select-orderBy-offset-limit]]

<<TOC_,To TOC>>

==== 5-1-10. SELECT with ORDER BY, OFFSET and LIMIT

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .orderBy("{lastName}")
        .orderBy("{firstName}")
        .orderBy("{id}")
        .offset(10).limit(5)
        .connection(conn)
        .select(contacts::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
Transaction.execute {
    new Sql<>(Contact)
        .orderBy('{lastName}')
        .orderBy('{firstName}')
        .orderBy('{id}')
        .offset(10).limit(5)
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.Generated SQL - DB2, MySQL, PostgreSQL, SQLite
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  ORDER BY lastName ASC, firstName ASC, id ASC
  LIMIT 5 OFFSET 10
----

[source,sql]
.Generated SQL - Oracle, SQLServer (Skip rows during getting)
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact
  ORDER BY lastName ASC, firstName ASC, id ASC
----

[[ExecuteSQL-select-forUpdate]]

<<TOC_,To TOC>>

==== 5-1-11. SELECT with FOR UPDATE

[source,java]
.Java
----
Transaction.execute(conn -> {
    Optional<Contact> contactOpt = new Sql<>(Contact.class)
        .where("{id}={}", 1)
        .forUpdate()
        .connection(conn)
        .select();
});
----

[source,groovy]
.Groovy
----
Transaction.execute {
    def contactOpt = new Sql<>(Contact)
        .where('{id}={}', 1)
        .forUpdate()
        .connection(it)
        .select()
}
----

[source,sql]
.Generated SQL - DB2
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1 FOR UPDATE WITH RS
----

[source,sql]
.Generated SQL - MySQL, Oracle, PostgreSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1 FOR UPDATE
----

[source,sql]
.Generated SQL - SQLite
----
-- UnsupportedOperationException is thrown on SQLite because FOR UPDATE is not supported.
----

[source,sql]
.Generated SQL - SQLServer
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WITH (ROWLOCK,UPDLOCK) WHERE id=1
----

[[ExecuteSQL-select-innerJoin]]

<<TOC_,To TOC>>

==== 5-1-12. SELECT with INNER JOIN

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
List<Phone> phones = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class, "C")
        .innerJoin(Phone.class, "P", "{P.contactId}={C.id}")
        .where("{C.id}={}", 1)
        .connection(conn)
        .<Phone>select(contacts::add, phones::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
List<Phone> phones = []
Transaction.execute {
    new Sql<>(Contact, 'C')
        .innerJoin(Phone, 'P', '{P.contactId}={C.id}')
        .where('{C.id}={}', 1)
        .connection(it)
        .select({contacts << it}, {phones << it})
}
----

[source,sql]
.Generated SQL
----
SELECT C.id C_id, C.firstName C_firstName, C.lastName C_lastName, C.birthday C_birthday, C.updateCount C_updateCount, C.createdTime C_createdTime, C.updatedTime C_updatedTime, P.contactId P_contactId, P.featureIndex P_featureIndex, P.label P_label, P.content P_content
  FROM Contact C
  INNER JOIN Phone P ON P.contactId=C.id
  WHERE C.id=1
----

[[ExecuteSQL-select-leftJoin]]

<<TOC_,To TOC>>

==== 5-1-13. SELECT with LEFT OUTER JOIN

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
List<Phone> phones = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class, "C")
        .leftJoin(Phone.class, "P", "{P.contactId}={C.id}")
        .where("{C.lastName}={}", "Apple")
        .connection(conn)
        .<Phone>select(contacts::add, phones::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
List<Phone> phones = []
Transaction.execute {
    new Sql<>(Contact, 'C')
        .leftJoin(Phone, 'P', '{P.contactId}={C.id}')
        .where('{C.lastName}={}', 'Apple')
        .connection(it)
        .select({contacts << it}, {phones << it})
}
----

[source,sql]
.Generated SQL
----
SELECT C.id C_id, C.firstName C_firstName, C.lastName C_lastName, C.birthday C_birthday, C.updateCount C_updateCount, C.createdTime C_createdTime, C.updatedTime C_updatedTime, P.contactId P_contactId, P.featureIndex P_featureIndex, P.label P_label, P.content P_content
  FROM Contact C
  LEFT OUTER JOIN Phone P ON P.contactId=C.id
  WHERE C.lastName='Apple'
----

[[ExecuteSQL-select-rightJoin]]

<<TOC_,To TOC>>

==== 5-1-14. SELECT with RIGHT OUTER JOIN

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
List<Phone> phones = new ArrayList<>();
Transaction.execute(conn ->
    new Sql<>(Contact.class, "C")
        .rightJoin(Phone.class, "P", "{P.contactId}={C.id}")
        .where("{P.label}={}", "Main")
        .connection(conn)
        .<Phone>select(contacts::add, phones::add)
);
----

[source,groovy]
.Groovy
----
List<Contact> contacts = []
List<Phone> phones = []
Transaction.execute {
    new Sql<>(Contact, 'C')
        .rightJoin(Phone, 'P', '{P.contactId}={C.id}')
        .where('{P.label}={}', 'Main')
        .connection(it)
        .select({contacts << it}, {phones << it})
}
----

[source,sql]
.Generated SQL
----
-- An exception is thrown in SQLite because RIGHT OUTER JOIN is not supported.
SELECT C.id C_id, C.firstName C_firstName, C.lastName C_lastName, C.birthday C_birthday, C.updateCount C_updateCount, C.createdTime C_createdTime, C.updatedTime C_updatedTime, P.contactId P_contactId, P.featureIndex P_featureIndex, P.label P_label, P.content P_content
  FROM Contact C
  RIGHT OUTER JOIN Phone P ON P.contactId=C.id
  WHERE P.label='Main'
----

[[ExecuteSQL-select-count]]

<<TOC_,To TOC>>

==== 5-1-15. SELECT COUNT(*)

[source,java]
.Java
----
int[] count = new int[1];
Transaction.execute(conn ->
    count[0] = new Sql<>(Contact.class)
        .where("lastName={}", "Apple")
        .connection(conn)
        .selectCount()
);
----

[source,groovy]
.Groovy
----
def count = 0
Transaction.execute {
    count = new Sql<>(Contact)
        .where('lastName={}', 'Apple')
        .connection(it)
        .selectCount()
}
----

[source,sql]
.Generated SQL
----
SELECT COUNT(*) FROM Contact WHERE lastName='Apple'
----

[[ExecuteSQL-select-fromSubquery]]

<<TOC_,To TOC>>

==== 5-1-16. SELECT FROM Clause Subquery

[source,java]
.Java
----
List<Contact> contacts = new ArrayList<>();
Transaction.execute(conn -> {
    Class<? extends Contact.Ex> contactClass = Contact.Ex.targetClass(conn.getDatabase());
    new Sql<>(contactClass)
        .from(new Sql<>(contactClass))
        .where("{fullName}={}", "Akane Apple")
        .orderBy("{fullName}")
        .connection(conn)
        .select(contacts::add);
});
----

[source,groovy]
.Groovy
----
def contacts = []
Transaction.execute {
    def contactClass = Contact.Ex.targetClass(conn.database)
    new Sql<>(contactClass)
        .from(new Sql<>(contactClass))
        .where('{fullName}={}', 'Akane Apple')
        .orderBy('{fullName}')
        .connection(it)
        .select({contacts << it})
}
----

[source,sql]
.Generated SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime, fullName
  FROM (
    SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime, firstName||' '||lastName fullName FROM Contact
  ) Contact
  WHERE fullName='Akane Apple' ORDER BY fullName ASC
----

[[ExecuteSQL-select-union]]

<<TOC_,To TOC>>

==== 5-1-17. SELECT UNION, UNION ALL

[source,java]
.Java
----
List<ContactFeature> features = new ArrayList<>();
String targetFirstName = "Setoka";
String targetLastName = "Orange";
Transaction.execute(conn -> {
    new Sql<>(ContactFeature.class, "F")
        .columns(ContactFeature.class)
        .unionAll(new Sql<>(Address.class)
            .innerJoin(Contact.class, "C", "{C.id}={F.contactId}")
            .where("{C.firstName}={}", targetFirstName)
            .and("{C.lastName}={}", targetLastName)
            .and("{F.featureIndex}={}", 1)
        )
        .unionAll(new Sql<>(Email.class)
            .innerJoin(Contact.class, "C", "{C.id}={F.contactId}")
            .where("{C.firstName}={}", targetFirstName)
            .and("{C.lastName}={}", targetLastName)
            .and("{F.featureIndex}={}", 1)
        )
        .unionAll(new Sql<>(Phone.class)
            .innerJoin(Contact.class, "C", "{C.id}={F.contactId}")
            .where("{C.firstName}={}", targetFirstName)
            .and("{C.lastName}={}", targetLastName)
            .and("{F.featureIndex}={}", 1)
        )
        .unionAll(new Sql<>(Url.class)
            .innerJoin(Contact.class, "C", "{C.id}={F.contactId}")
            .where("{C.firstName}={}", targetFirstName)
            .and("{C.lastName}={}", targetLastName)
            .and("{F.featureIndex}={}", 1)
        )
        .orderBy("{F_label}")
        .connection(conn)
        .select(features::add);
});
----

[source,groovy]
.Groovy
----
def features = []
def targetFirstName = 'Setoka'
def targetLastName = 'Orange'
Transaction.execute {
    new Sql<>(ContactFeature, 'F')
        .columns(ContactFeature)
        .unionAll(new Sql<>(Address)
            .innerJoin(Contact, 'C', '{C.id}={F.contactId}')
            .where('{C.firstName}={}', targetFirstName)
            .and('{C.lastName}={}', targetLastName)
            .and('{F.featureIndex}={}', 1)
        )
        .unionAll(new Sql<>(Email)
            .innerJoin(Contact, 'C', '{C.id}={F.contactId}')
            .where('{C.firstName}={}', targetFirstName)
            .and('{C.lastName}={}', targetLastName)
            .and('{F.featureIndex}={}', 1)
        )
        .unionAll(new Sql<>(Phone)
            .innerJoin(Contact, 'C', '{C.id}={F.contactId}')
            .where('{C.firstName}={}', targetFirstName)
            .and('{C.lastName}={}', targetLastName)
            .and('{F.featureIndex}={}', 1)
        )
        .unionAll(new Sql<>(Url)
            .innerJoin(Contact, 'C', '{C.id}={F.contactId}')
            .where('{C.firstName}={}', targetFirstName)
            .and('{C.lastName}={}', targetLastName)
            .and('{F.featureIndex}={}', 1)
        )
        .orderBy('{F_label}')
        .connection(it)
        .select({features << it})
}
----

[source,sql]
.Generated SQL
----
SELECT F.contactId F_contactId, F.featureIndex F_featureIndex, F.label F_label, F.content F_content
  FROM Address F
  INNER JOIN Contact C ON C.id=F.contactId
  WHERE C.firstName='Setoka' AND C.lastName='Orange' AND F.featureIndex=1
UNION ALL
SELECT F.contactId F_contactId, F.featureIndex F_featureIndex, F.label F_label, F.content F_content
  FROM Email F
  INNER JOIN Contact C ON C.id=F.contactId
  WHERE C.firstName='Setoka' AND C.lastName='Orange' AND F.featureIndex=1
UNION ALL
SELECT F.contactId F_contactId, F.featureIndex F_featureIndex, F.label F_label, F.content F_content
  FROM Phone F
  INNER JOIN Contact C ON C.id=F.contactId
  WHERE C.firstName='Setoka' AND C.lastName='Orange' AND F.featureIndex=1
UNION ALL
SELECT F.contactId F_contactId, F.featureIndex F_featureIndex, F.label F_label, F.content F_content
  FROM Url F
  INNER JOIN Contact C ON C.id=F.contactId
  WHERE C.firstName='Setoka' AND C.lastName='Orange' AND F.featureIndex=1
ORDER BY F_label ASC
----

[[ExecuteSQL-insert]]

<<TOC_,To TOC>>

==== 5-2. INSERT

[[ExecuteSQL-insert-1]]

==== 5-2-1. INSERT 1 row

[source,java]
.Java
----
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .connection(conn)
        .insert(new Contact(1, "Akane", "Apple", 2001, 1, 1))
----

[source,groovy]
.Groovy
----
Transaction.execute {
    new Sql<>(Contact)
       .connection(it)
       .insert(new Contact(1, "Akane", "Apple", 2001, 1, 1))
}
----

[source,sql]
.Generated SQL - DB2, MySQL, Oracle, PostgreSQL
----
INSERT INTO Contact
  (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (1, 'Akane', 'Apple', DATE'2001-01-01', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[source,sql]
.Generated SQL - SQLite
----
INSERT INTO Contact
  (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (1, 'Akane', 'Apple', '2001-01-01', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[source,sql]
.Generated SQL - SQLServer
----
INSERT INTO Contact
  (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (1, 'Akane', 'Apple', CAST('2001-01-01' AS DATE), 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[[ExecuteSQL-insert-N]]

<<TOC_,To TOC>>

==== 5-2-2. INSERT multiple rows

[source,java]
.Java
----
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .connection(conn)
        .insert(Arrays.asList(
            new Contact(2, "Yukari", "Apple", 2001, 1, 2),
            new Contact(3, "Azusa", "Apple", 2001, 1, 3)
        ))
----

[source,groovy]
.Groovy
----
Transaction.execute {
    new Sql<>(Contact)
        .connection(it)
        .insert([
            new Contact(2, "Yukari", "Apple", 2001, 1, 2),
            new Contact(3, "Azusa", "Apple", 2001, 1, 3)
        ])
}
----

[source,sql]
.Generated SQL - DB2, MySQL, Oracle, PostgreSQL
----
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (2, 'Yukari', 'Apple', DATE'2001-01-02', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (3, 'Azusa', 'Apple', DATE'2001-01-03', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[source,sql]
.Generated SQL - SQLite
----
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (2, 'Yukari', 'Apple', '2001-01-02', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (3, 'Azusa', 'Apple', '2001-01-03', 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[source,sql]
.Generated SQL - SQLServer
----
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (2, 'Yukari', 'Apple', CAST('2001-01-02' AS DATE), 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
INSERT INTO Contact (id, firstName, lastName, birthday, updateCount, createdTime, updatedTime)
  VALUES
  (3, 'Azusa', 'Apple', CAST('2001-01-03' AS DATE), 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
----

[[ExecuteSQL-update]]

<<TOC_,To TOC>>

==== 5-3. UPDATE

[[ExecuteSQL-update-1]]

==== 5-3-1. UPDATE 1 row

[source,java]
.Java
----
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{id}={}", 1)
        .connection(conn)
        .select()
        .ifPresent(contact -> {
            contact.firstName = "Akiyo";
            new Sql<>(Contact.class)
                .connection(conn)
                .update(contact);
        })
);
----

[source,groovy]
.Groovy
----
Transaction.execute {
    new Sql<>(Contact)
        .where('{id}={}', 1)
        .connection(it)
        .select()
        .ifPresent {Contact contact ->
            contact.firstName = 'Akiyo'
            new Sql<>(Contact)
                .connection(it)
                .update(contact)
        }
}
----

[source,sql]
.Generated SQL - DB2, MySQL, Oracle, PostgreSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1
UPDATE Contact SET
  firstName='Akiyo', lastName='Apple', birthday=DATE'2001-01-01', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP WHERE id=1
----

[source,sql]
.Generated SQL - SQLite
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1
UPDATE Contact SET
  firstName='Akiyo', lastName='Apple', birthday='2001-01-01', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP WHERE id=1
----

[source,sql]
.Generated SQL - SQLServer
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1
UPDATE Contact SET
  firstName='Akiyo', lastName='Apple', birthday=CAST('2001-01-01' AS DATE), updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP WHERE id=1
----

[[ExecuteSQL-update-N]]

<<TOC_,To TOC>>

==== 5-3-2. UPDATE multiple rows

[source,java]
.Java
----
Transaction.execute(conn -> {
    List<Contact> contacts = new ArrayList<>();
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apple")
        .connection(conn)
        .select(contact -> {
            contact.lastName = "Apfel";
            contacts.add(contact);
        });
    new Sql<>(Contact.class)
        .connection(conn)
        .update(contacts);
});
----

[source,groovy]
.Groovy
----
Transaction.execute {
    List<Contact> contacts = []
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apple')
        .connection(it)
        .select({Contact contact ->
            contact.lastName = 'Apfel'
            contacts << contact
        })
    new Sql<>(Contact)
        .connection(it)
        .update(contacts)
}
----

[source,sql]
.Generated SQL - DB2, MySQL, Oracle, PostgreSQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE lastName='Apple'
UPDATE Contact SET
  firstName='Akiyo', lastName='Apfel', birthday=DATE'2001-01-01', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=1
UPDATE Contact SET
  firstName='Yukari', lastName='Apfel', birthday=DATE'2001-01-02', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=2
UPDATE Contact SET
  firstName='Azusa', lastName='Apfel', birthday=DATE'2001-01-03', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=3
----

[source,sql]
.Generated SQL - SQLite
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE lastName='Apple'
UPDATE Contact SET
  firstName='Akiyo', lastName='Apfel', birthday='2001-01-01', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=1
UPDATE Contact SET
  firstName='Yukari', lastName='Apfel', birthday='2001-01-02', updateCount=updateCount+1, updatdTime=CURRENT_TIMESTAMP
  WHERE id=2
UPDATE Contact SET
  firstName='Azusa', lastName='Apfel', birthday='2001-01-03', updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=3
----

[source,sql]
.Generated SQL - SQLServer
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE lastName='Apple'
UPDATE Contact SET
  firstName='Akiyo', lastName='Apfel', birthday=CAST('2001-01-01' AS DATE), updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=1
UPDATE Contact SET
  firstName='Yukari', lastName='Apfel', birthday=CAST('2001-01-02' AS DATE), updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=2
UPDATE Contact
  SET firstName='Azusa', lastName='Apfel', birthday=CAST('2001-01-03' AS DATE), updateCount=updateCount+1, updatedTime=CURRENT_TIMESTAMP
  WHERE id=3
----

[[ExecuteSQL-update-Condition]]

<<TOC_,To TOC>>

==== 5-3-3. UPDATE with a Condition and selection of columns

[source,java]
.Java
----
Contact contact = new Contact();
contact.lastName = "Pomme";
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Apfel")
        .columns("lastName")
        .connection(conn)
        .update(contact)
);
----

[source,groovy]
.Groovy
----
def contact = new Contact()
contact.lastName = 'Pomme'
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Apfel')
        .columns('lastName')
        .connection(it)
        .update(contact)
}
----

[source,sql]
.Generated SQL
----
UPDATE Contact SET lastName='Pomme' WHERE lastName='Apfel'
----

[[ExecuteSQL-update-all]]

<<TOC_,To TOC>>

==== 5-3-4. UPDATE all rows

[source,java]
.Java
----
Contact contact = new Contact();
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where(Condition.ALL)
        .columns("birthday")
        .connection(conn)
        .update(contact)
);
----

[source,groovy]
.Groovy
----
def contact = new Contact()
Transaction.execute {
    new Sql<>(Contact)
        .where(Condition.ALL)
        .columns('birthday')
        .connection(it)
        .update(contact)
}
----

[source,sql]
.Generated SQL
----
UPDATE Contact SET birthday=NULL
----


[[ExecuteSQL-delete]]

<<TOC_,To TOC>>

==== 5-4. DELETE

[[ExecuteSQL-delete-1]]

==== 5-4-1. DELETE 1 row

[source,java]
.Java
----
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{id}={}", 1)
        .connection(conn)
        .select()
        .ifPresent(contact ->
            new Sql<>(Contact.class)
                .connection(conn)
                .delete(contact))
);
----

[source,groovy]
.Groovy
----
Transaction.execute {
    new Sql<>(Contact)
        .where('{id}={}', 1)
        .connection(it)
        .select()
        .ifPresent {contact ->
            new Sql<>(Contact)
                .connection(it)
                .delete(contact)
        }
}
----

[source,sql]
.Generated SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE id=1
DELETE FROM Contact WHERE id=1
----


[[ExecuteSQL-delete-N]]

==== 5-4-2. DELETE multiple rows

[source,java]
.Java
----
Transaction.execute(conn -> {
    List<Contact> contacts = new ArrayList<>();
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Pomme")
        .connection(conn)
        .select(contacts::add);
    new Sql<>(Contact.class)
        .connection(conn)
        .delete(contacts);
});
----

[source,groovy]
.Groovy
----
Transaction.execute {
    List<Contact> contacts = []
    new Sql<>(Contact)
        .where('{lastName}={}', 'Pomme')
        .connection(it)
        .select({contacts << it})
    new Sql<>(Contact)
        .connection(it)
        .delete(contacts)
}
----

[source,sql]
.Generated SQL
----
SELECT id, firstName, lastName, birthday, updateCount, createdTime, updatedTime
  FROM Contact WHERE lastName='Pomme'
DELETE FROM Contact WHERE id=2
DELETE FROM Contact WHERE id=3
----

[[ExecuteSQL-delete-Condition]]

==== 5-4-3. DELETE with a Condition

[source,java]
.Java
----
Transaction.execute(conn ->
    new Sql<>(Contact.class)
        .where("{lastName}={}", "Orange")
        .connection(conn)
        .delete()
);
----

[source,groovy]
.Groovy
----
Transaction.execute {
    new Sql<>(Contact)
        .where('{lastName}={}', 'Orange')
        .connection(it)
        .delete()
}
----

[source,sql]
.Generated SQL
----
DELETE FROM Contact WHERE lastName='Orange'
----

[[ExecuteSQL-delete-all]]

==== 5-4-4. DELETE all rows

[source,java]
.Java
----
Transaction.execute(conn ->
    new Sql<>(Phone.class)
        .where(Condition.ALL)
        .connection(conn)
        .delete()
);
----

[source,groovy]
.Groovy
----
Transaction.execute {
    new Sql<>(Phone)
        .where(Condition.ALL)
        .connection(it)
        .delete()
}
----

[source,sql]
.Generated SQL
----
DELETE FROM Phone
----

[[Expression]]

<<TOC_,To TOC>>

=== 6. Expression Conversion

When generating SQL, evaluates the following character string as an expression and perform conversion processing.

* The value of `@Select`, `@Insert` and `@Update`

* The value of `expression` of `@SelectProperty`, `@InsertProperty` and `@UpdateProperty` annotations.

* Arguments for the following methods of the `Sql` class
** `where(String content, Object... arguments)`
** `where(String content, Sql<SE> subSql)`
** `where(Sql<SE> subSql, String content)` [small fuchsia]#_(since 3.1.0)_#
** `and(String content, Object... arguments)`
** `and(String content, Sql<SE> subSql)`
** `and(Sql<SE> subSql, String content)` [small fuchsia]#_(since 3.1.0)_#
** `or(String content, Object... arguments)`
** `or(String content, Sql<SE> subSql)`
** `or(Sql<SE> subSql, String content)` [small fuchsia]#_(since 3.1.0)_#
** `groupBy(String content, Object... arguments)`
** `having(String content, Object... arguments)`
** `having(String content, Sql<SE> subSql)`
** `having(Sql<SE> subSql, String content)` [small fuchsia]#_(since 3.1.0)_#
** `orderBy(String content, Object... arguments)`

* Arguments for the following methods of the `Condition` interface
** `of(String content, Object... arguments)`
** `of(String content, Sql<E> outerSql, Sql<SE> subSql)`
** `of(Sql<E> outerSql, Sql<SE> subSql, String content)` [small fuchsia]#_(since 3.1.0)_#
** `and(String content, Object... arguments)`
** `and(String content, Sql<E> outerSql, Sql<SE> subSql)`
** `and(Sql<E> outerSql, Sql<SE> subSql, String content)` [small fuchsia]#_(since 3.1.0)_#
** `or(String content, Object... arguments)`
** `or(String content, Sql<E> outerSql, Sql<SE> subSql)`
** `or(Sql<E> outerSql, Sql<SE> subSql, String content)` [small fuchsia]#_(since 3.1.0)_#

* Arguments of the following constructor of the `Expression` class
** `Expression(String content, Object... arguments)`

Conversion of expressions has the followings.

[options="header", width="80%"]
|===
|Format|Conversion Content
|`{}`|An element of `arguments` in appearance
|`{xxx}`|The column name related to property `xxx`
|`{A.xxx}`|`"A."` + The column name related to property `xxx` (`A` is a table alias)
|`{A_xxx}`|The column alias related to table alias `A` and `xxx` property
|`{#xxx}`|The value of property `xxx` of an entity set on the `Sql` object (or an entity argument of `Sql#insert` or `Sql#update` method)
|===

[[DateTime]]

<<TOC_,To TOC>>

=== 7. Mappings of Java types and column types in datetime types

[[DateTime-DB2]]

===== 7.1 DB2

[options="header", width="70%", cols=",^,^,^,"]
|===
|                          |`DATE`|`TIME` |`TIMESTAMP(9)`|
|`java.util.Date`          |     |       |              |
|`java.sql.Date`           |     |       |              |
|`java.sql.Time`           |      | (sec)|              |
|`java.sql.Timestamp`      |     |       | (10^9^ sec) |
|`java.time.LocalDate`     |      |       |              |[small fuchsia]#_since 3.0.0_#
|`java.time.LocalTime`     |      | (sec)|              |[small fuchsia]#_since 3.0.0_#
|`java.time.LocalDateTime` |      |       | (10^9^ sec) |[small fuchsia]#_since 3.0.0_#
|`java.time.OffsetDateTime`|      |       |              |[small fuchsia]#_since 3.0.0_#
|`java.time.ZonedDateTime` |      |       |              |[small fuchsia]#_since 3.0.0_#
|`java.time.Instant`       |      |       |              |[small fuchsia]#_since 3.0.0_#
|===

[[DateTime-MySQL]]

===== 7.2 MySQL

[options="header", width="80%", cols=",^,^,^,^,"]
|===
|                          |`DATE`|`TIME`       |`DATETIME`   |`TIMESTAMP`  |
|`java.util.Date`          |     |             |             |             |
|`java.sql.Date`           |     |             |             |             |
|`java.sql.Time`           |      | (10^3^ sec)|             |             |
|`java.sql.Timestamp`      |     |             | (10^6^ sec)| (10^6^ sec)|
|`java.time.LocalDate`     |      |             |             |             |[small fuchsia]#_since 3.0.0_#
|`java.time.LocalTime`     |      | (10^6^ sec)|             |             |[small fuchsia]#_since 3.0.0_#
|`java.time.LocalDateTime` |      |             | (10^6^ sec)| (10^6^ sec)|[small fuchsia]#_since 3.0.0_#
|`java.time.OffsetDateTime`|      |             |             |             |[small fuchsia]#_since 3.0.0_#
|`java.time.ZonedDateTime` |      |             |             |             |[small fuchsia]#_since 3.0.0_#
|`java.time.Instant`       |      |             |             |             |[small fuchsia]#_since 3.0.0_#
|===

[[DateTime-Oracle]]

===== 7.3 Oracle

[options="header", width="85%", cols=",^,^,^,^,"]
|===
|                          |`DATE` |`TIMESTAMP(9)`|`TIMESTAMP(9) WITH TIME ZONE`|`TIMESTAMP(9) WITH LOCAL TIME ZONE`|
|`java.util.Date`          |      |              |                             |                                   |
|`java.sql.Date`           |      |              |                             |                                   |
|`java.sql.Time`           | (sec)|              |                             |                                   |
|`java.sql.Timestamp`      | (sec)| (10^9^ sec) |                             | (10^9^ sec)                      |
|`java.time.LocalDate`     | (sec)|              |                             |                                   |[small fuchsia]#_since 3.0.0_#
|`java.time.LocalTime`     | (sec)|              |                             |                                   |[small fuchsia]#_since 3.0.0_#
|`java.time.LocalDateTime` | (sec)| (10^9^ sec) |                             | (10^9^ sec)                      |[small fuchsia]#_since 3.0.0_#
|`java.time.OffsetDateTime`|       |              | (10^9^ sec)                |                                   |[small fuchsia]#_since 3.0.0_#
|`java.time.ZonedDateTime` |       |              | (10^9^ sec)                |                                   |[small fuchsia]#_since 3.0.0_#
|`java.time.Instant`       |       |              | (10^9^ sec)                |                                   |[small fuchsia]#_since 3.0.0_#
|===

[[DateTime-PostgreSQL]]

===== 7.4 PostgreSQL

[options="header", width="90%", cols=",^,^,^,^,"]
|===
|                          |`DATE`|`TIME(6)`    |`TIMESTAMP(6)`|`TIMESTAMP(6) WITH TIME ZONE`|
|`java.util.Date`          |     |             |              |                             |
|`java.sql.Date`           |     |             |              |                             |
|`java.sql.Time`           |      | (10^3^ sec)|              |                             |
|`java.sql.Timestamp`      |     |             | (10^6^ sec) |                             |
|`java.time.LocalDate`     |      |             |              |                             |[small fuchsia]#_since 3.0.0_#
|`java.time.LocalTime`     |      | (10^6^ sec)|              |                             |[small fuchsia]#_since 3.0.0_#
|`java.time.LocalDateTime` |      |             | (10^6^ sec) |                             |[small fuchsia]#_since 3.0.0_#
|`java.time.OffsetDateTime`|      |             |              | (10^6^ sec)                |[small fuchsia]#_since 3.0.0_#
|`java.time.ZonedDateTime` |      |             |              |                             |[small fuchsia]#_since 3.0.0_#
|`java.time.Instant`       |      |             |              | (10^6^ sec)                |[small fuchsia]#_since 3.0.0_#
|===

[[DateTime-SQLite]]

===== 7.5 SQLite

[options="header", width="50%", cols=",^,"]
|===
|                          |`DATE`, `TIME`, `DATETIME`, `TEXT`|
|`java.util.Date`          |                                 |
|`java.sql.Date`           |                                 |
|`java.sql.Time`           | (10^3^ sec)                     |
|`java.sql.Timestamp`      | (10^9^ sec)                     |
|`java.time.LocalDate`     | (10^9^ sec)                     |[small fuchsia]#_since 3.0.0_#
|`java.time.LocalTime`     | (10^9^ sec)                     |[small fuchsia]#_since 3.0.0_#
|`java.time.LocalDateTime` | (10^9^ sec)                     |[small fuchsia]#_since 3.0.0_#
|`java.time.OffsetDateTime`| (10^9^ sec)                     |[small fuchsia]#_since 3.0.0_#
|`java.time.ZonedDateTime` | (10^9^ sec)                     |[small fuchsia]#_since 3.0.0_#
|`java.time.Instant`       | (10^9^ sec)                     |[small fuchsia]#_since 3.0.0_#
|===

[[DateTime-SQLServer]]

===== 7.6 SQL Server

[options="header", width="90%", cols=",^,^,^,^,"]
|===
|                          |`DATE`|`TIME(7)`    |`DATETIME2(7)`|`DATETIMEOFFSET(7)`|
|`java.util.Date`          |     |             |              |                   |
|`java.sql.Date`           |     |             |              |                   |
|`java.sql.Time`           |      | (10^3^ sec)|              |                   |
|`java.sql.Timestamp`      |     |             | (10^7^ sec) |                   |
|`java.time.LocalDate`     |      |             |              |                   |[small fuchsia]#_since 3.0.0_#
|`java.time.LocalTime`     |      | (10^3^ sec)|              |                   |[small fuchsia]#_since 3.0.0_#
|`java.time.LocalDateTime` |      |             | (10^7^ sec) |                   |[small fuchsia]#_since 3.0.0_#
|`java.time.OffsetDateTime`|      |             |              | (10^7^ sec)      |[small fuchsia]#_since 3.0.0_#
|`java.time.ZonedDateTime` |      |             |              |                   |[small fuchsia]#_since 3.0.0_#
|`java.time.Instant`       |      |             |              | (10^7^ sec)      |[small fuchsia]#_since 3.0.0_#
|===

[gray]#_(C) 2015 Masato Kokubo_#
